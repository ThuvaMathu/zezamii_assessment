import express from "express";
import pkg from "mssql";

const dbRouters = express.Router();
//Retrieve all orders and their associated customer details

dbRouters.get("/orders-with-customers", async (req, res) => {
  try {
    const { pool } = req.app.locals;
    const ordersQuery = `
      SELECT Orders.OrderID, Orders.OrderDate, Customers.CustomerName, Customers.Email
      FROM Orders
      JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
    `;

    const result = await pool.request().query(ordersQuery);
    res.json(result.recordset);
  } catch (err) {
    res.status(500).send("Error fetching orders: " + err);
  }
});

//Retrieve a list of products not ordered in the last 30 days.
dbRouters.get("/products-list", async (req, res) => {
  try {
    const { pool } = req.app.locals;
    const productsQuery = `
      SELECT ProductID, ProductName FROM Products
      WHERE ProductID NOT IN (
        SELECT DISTINCT ProductID FROM OrderItems
        JOIN Orders ON OrderItems.OrderID = Orders.OrderID
        WHERE Orders.OrderDate > DATEADD(DAY, -30, GETDATE())
      );
    `;

    const result = await pool.request().query(productsQuery);
    res.json(result.recordset);
  } catch (err) {
    res.status(500).send("Error fetching products: " + err);
  }
});

//Update a productâ€™s price and reflect that in all current orders.
dbRouters.put("/update-price", async (req, res) => {
  console.log(req.body);
  try {
    const { pool } = req.app.locals;
    const { productID, newPrice } = req.body;
    const updateQuery = `
      UPDATE Products
      SET Price = @newPrice
      WHERE ProductID = @productID;
    `;

    await pool
      .request()
      .input("productID", pkg.Int, productID)
      .input("newPrice", pkg.Decimal(10, 2), newPrice)
      .query(updateQuery);

    res.send("Product price updated successfully");
  } catch (err) {
    res.status(500).send("Error updating product price: " + err);
  }
});

//Create a stored procedure that accepts a customer ID and returns their order history, including product details.
dbRouters.get("/order-history/:customerID", async (req, res) => {
  try {
    const { pool } = req.app.locals;
    const customerID = req.params.customerID;

    const orderHistoryQuery = `
    SELECT 
      Orders.OrderID,
      Orders.OrderDate,
      Products.ProductID,
      Products.ProductName,
      Products.Price,
      OrderItems.Quantity,
      (Products.Price * OrderItems.Quantity) AS TotalPrice
    FROM Orders
    JOIN OrderItems ON Orders.OrderID = OrderItems.OrderID
    JOIN Products ON OrderItems.ProductID = Products.ProductID
    WHERE Orders.CustomerID = @CustomerID
    ORDER BY Orders.OrderDate DESC;
  `;
    const result = await pool
      .request()
      .input("CustomerID", customerID)
      .query(orderHistoryQuery);
    res.json(result.recordset);
  } catch (err) {
    console.error("Error fetching customer order history:", err);
    res
      .status(500)
      .send("Error fetching customer order history: " + err.message);
  }
});

//query that returns the total revenue generated by each customer.
dbRouters.get("/total-revenue", async (req, res) => {
  try {
    const { pool } = req.app.locals;

    const revenueQuery = `
      SELECT Customers.CustomerName, SUM(OrderItems.Quantity * Products.Price) AS TotalRevenue
      FROM Orders
      JOIN Customers ON Orders.CustomerID = Customers.CustomerID
      JOIN OrderItems ON Orders.OrderID = OrderItems.OrderID
      JOIN Products ON OrderItems.ProductID = Products.ProductID
      GROUP BY Customers.CustomerName;
    `;

    const result = await pool.request().query(revenueQuery);
    res.json(result.recordset);
  } catch (err) {
    res.status(500).send("Error fetching total revenue: " + err);
  }
});

export default dbRouters;
